<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Omroneip: omronUtilities Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Omroneip
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">An EPICS asyn driver for communicating with OmronNJ/NX PLC&#39;s using etherIP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classomron_utilities-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">omronUtilities Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="omron_utilities_8h_source.html">omronUtilities.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab38ced4cd1db5cec06be780aae802c44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#ab38ced4cd1db5cec06be780aae802c44">omronUtilities</a> (<a class="el" href="classdrv_omron_e_i_p.html">drvOmronEIP</a> *<a class="el" href="classomron_utilities.html#a4704ea03c03ae7c9b4e7017e157ab212">pDriver</a>)</td></tr>
<tr class="separator:ab38ced4cd1db5cec06be780aae802c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7102779a9f2e772193b684d112e183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a9f7102779a9f2e772193b684d112e183">~omronUtilities</a> ()</td></tr>
<tr class="separator:a9f7102779a9f2e772193b684d112e183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456974c2bad79d3c5436f79b706ae9dc"><td class="memItemLeft" align="right" valign="top">asynStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a456974c2bad79d3c5436f79b706ae9dc">createStructMap</a> (<a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> rawMap)</td></tr>
<tr class="separator:a456974c2bad79d3c5436f79b706ae9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719937e10d3d8f317c7fb56a8b0e264f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a719937e10d3d8f317c7fb56a8b0e264f">expandArrayRecursive</a> (<a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;rawMap, std::string arrayDesc)</td></tr>
<tr class="separator:a719937e10d3d8f317c7fb56a8b0e264f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72301440015adfb63019700fa001a0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#adb72301440015adfb63019700fa001a0">expandStructsRecursive</a> (<a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;rawMap, std::string structName)</td></tr>
<tr class="separator:adb72301440015adfb63019700fa001a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f8a76977a452bb59294184bdaf5fc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#af5f8a76977a452bb59294184bdaf5fc1">getEmbeddedAlignment</a> (<a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;expandedMap, std::string structName, std::string nextItem, size_t i)</td></tr>
<tr class="separator:af5f8a76977a452bb59294184bdaf5fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cac6bd5343b42da5f14fd3ff3ffb871"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a1cac6bd5343b42da5f14fd3ff3ffb871">findOffsets</a> (<a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;expandedMap, std::string structName, std::unordered_map&lt; std::string, std::vector&lt; int &gt;&gt; &amp;structMap)</td></tr>
<tr class="separator:a1cac6bd5343b42da5f14fd3ff3ffb871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb6422a83deb2e9e7a51c9661509f79"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a7bb6422a83deb2e9e7a51c9661509f79">findArrayDtype</a> (<a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;expandedMap, std::string arrayDesc)</td></tr>
<tr class="separator:a7bb6422a83deb2e9e7a51c9661509f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cae6bedc11d6478b0c2c52cc74cb7c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a7cae6bedc11d6478b0c2c52cc74cb7c1">getBiggestDtype</a> (<a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;, std::string structName)</td></tr>
<tr class="separator:a7cae6bedc11d6478b0c2c52cc74cb7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9051c9882f037fef52cfc9129a0e6394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a9051c9882f037fef52cfc9129a0e6394">findRequestedOffset</a> (std::vector&lt; size_t &gt; indices, std::string structMap)</td></tr>
<tr class="separator:a9051c9882f037fef52cfc9129a0e6394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebf2f148c6e02fa7828b9080574cf41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a1ebf2f148c6e02fa7828b9080574cf41">processExtrasExceptions</a> (std::string thisWord, <a class="el" href="drv_omroneip_8h.html#a3d7ad34f0755c9afca3208c22f7afbf0">drvInfoMap</a> &amp;keyWords, std::string &amp;extrasString, <a class="el" href="drv_omroneip_8h.html#a3d7ad34f0755c9afca3208c22f7afbf0">drvInfoMap</a> &amp;defaultTagAttribs)</td></tr>
<tr class="separator:a1ebf2f148c6e02fa7828b9080574cf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb10f90ef8336adbadaa7596ac1b4805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="drv_omroneip_8h.html#a3d7ad34f0755c9afca3208c22f7afbf0">drvInfoMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#adb10f90ef8336adbadaa7596ac1b4805">drvInfoParser</a> (const char *drvInfo)</td></tr>
<tr class="separator:adb10f90ef8336adbadaa7596ac1b4805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d7a3f4f65a8ddda1ec2386935289b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a85d7a3f4f65a8ddda1ec2386935289b5">seperateDrvInfoVals</a> (std::string str, std::list&lt; std::string &gt; &amp;words)</td></tr>
<tr class="separator:a85d7a3f4f65a8ddda1ec2386935289b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164f5e6bfe11b1b5dc778ecc658cd52c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::string, std::string, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a164f5e6bfe11b1b5dc778ecc658cd52c">checkValidName</a> (const std::string str)</td></tr>
<tr class="separator:a164f5e6bfe11b1b5dc778ecc658cd52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73645e093f077d04d190ddd64afa4cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#ad73645e093f077d04d190ddd64afa4cc">checkValidDtype</a> (std::string str)</td></tr>
<tr class="separator:ad73645e093f077d04d190ddd64afa4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340f51492a9497605bde2af841859706"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a340f51492a9497605bde2af841859706">checkValidSliceSize</a> (std::string str, bool indexable, std::string dtype)</td></tr>
<tr class="separator:a340f51492a9497605bde2af841859706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad279bfac3f4af9076bf72e79fbfd6f8d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#ad279bfac3f4af9076bf72e79fbfd6f8d">checkValidOffset</a> (std::string str)</td></tr>
<tr class="separator:ad279bfac3f4af9076bf72e79fbfd6f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02fa183f6fdf7769c0b6ac5b801a0b6"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#ad02fa183f6fdf7769c0b6ac5b801a0b6">checkValidExtras</a> (std::string str, <a class="el" href="drv_omroneip_8h.html#a3d7ad34f0755c9afca3208c22f7afbf0">drvInfoMap</a> &amp;keyWords)</td></tr>
<tr class="separator:ad02fa183f6fdf7769c0b6ac5b801a0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4704ea03c03ae7c9b4e7017e157ab212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrv_omron_e_i_p.html">drvOmronEIP</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a4704ea03c03ae7c9b4e7017e157ab212">pDriver</a></td></tr>
<tr class="separator:a4704ea03c03ae7c9b4e7017e157ab212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b451095d9f8a31a33e42c3327f46e5"><td class="memItemLeft" align="right" valign="top">asynUser *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#a74b451095d9f8a31a33e42c3327f46e5">pasynUserSelf</a></td></tr>
<tr class="separator:a74b451095d9f8a31a33e42c3327f46e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2372cde9e153f6737e1d1f65ce2baad"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classomron_utilities.html#aa2372cde9e153f6737e1d1f65ce2baad">driverName</a></td></tr>
<tr class="separator:aa2372cde9e153f6737e1d1f65ce2baad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class which contains generic functions required by the driver </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab38ced4cd1db5cec06be780aae802c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38ced4cd1db5cec06be780aae802c44">&#9670;&nbsp;</a></span>omronUtilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">omronUtilities::omronUtilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrv_omron_e_i_p.html">drvOmronEIP</a> *&#160;</td>
          <td class="paramname"><em>pDriver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f7102779a9f2e772193b684d112e183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7102779a9f2e772193b684d112e183">&#9670;&nbsp;</a></span>~omronUtilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">omronUtilities::~omronUtilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad73645e093f077d04d190ddd64afa4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73645e093f077d04d190ddd64afa4cc">&#9670;&nbsp;</a></span>checkValidDtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string omronUtilities::checkValidDtype </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the user supplied dtype is valid, returns stringValid </p>

</div>
</div>
<a id="ad02fa183f6fdf7769c0b6ac5b801a0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02fa183f6fdf7769c0b6ac5b801a0b6">&#9670;&nbsp;</a></span>checkValidExtras()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::string, std::string &gt; omronUtilities::checkValidExtras </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#a3d7ad34f0755c9afca3208c22f7afbf0">drvInfoMap</a> &amp;&#160;</td>
          <td class="paramname"><em>keyWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the user supplied extras string is valid, returns a tuple of stringValid and extrasString </p>

</div>
</div>
<a id="a164f5e6bfe11b1b5dc778ecc658cd52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164f5e6bfe11b1b5dc778ecc658cd52c">&#9670;&nbsp;</a></span>checkValidName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::string, std::string, bool &gt; omronUtilities::checkValidName </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a tuple of &lt;stringValid,startIndex,indexable&gt; based on the tag name given, if the name is valid </p>

</div>
</div>
<a id="ad279bfac3f4af9076bf72e79fbfd6f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad279bfac3f4af9076bf72e79fbfd6f8d">&#9670;&nbsp;</a></span>checkValidOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::string, std::string &gt; omronUtilities::checkValidOffset </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the user supplied offset is valid, returns a tuple of stringValid and offset </p>

</div>
</div>
<a id="a340f51492a9497605bde2af841859706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340f51492a9497605bde2af841859706">&#9670;&nbsp;</a></span>checkValidSliceSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::string, std::string &gt; omronUtilities::checkValidSliceSize </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>indexable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the user supplied sliceSize is valid, returns a tuple of stringValid and sliceSize </p>

</div>
</div>
<a id="a456974c2bad79d3c5436f79b706ae9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456974c2bad79d3c5436f79b706ae9dc">&#9670;&nbsp;</a></span>createStructMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynStatus omronUtilities::createStructMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a>&#160;</td>
          <td class="paramname"><em>rawMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following group of functions are all used to calculate offsets form structure definition files Loops through each structure within the map and calls findOffsets which creates the final structure offset map </p>

</div>
</div>
<a id="adb10f90ef8336adbadaa7596ac1b4805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb10f90ef8336adbadaa7596ac1b4805">&#9670;&nbsp;</a></span>drvInfoParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="drv_omroneip_8h.html#a3d7ad34f0755c9afca3208c22f7afbf0">drvInfoMap</a> omronUtilities::drvInfoParser </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drvInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is responsible for parsing drvInfo when records are created. It takes the drvInfo string and parses it for required data. It returns a map of all of the data required by the driver to setup the asyn parameter and a boolean which indicates the validity of the data. </p>

</div>
</div>
<a id="a719937e10d3d8f317c7fb56a8b0e264f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719937e10d3d8f317c7fb56a8b0e264f">&#9670;&nbsp;</a></span>expandArrayRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; omronUtilities::expandArrayRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;&#160;</td>
          <td class="paramname"><em>rawMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>arrayDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively extract a list of all of the datatypes within an embedded array, this array may contain embedded structs in which case expandStructsRecursive is called </p>

</div>
</div>
<a id="adb72301440015adfb63019700fa001a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb72301440015adfb63019700fa001a0">&#9670;&nbsp;</a></span>expandStructsRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; omronUtilities::expandStructsRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;&#160;</td>
          <td class="paramname"><em>rawMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>structName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively extract a list of all of the datatypes within an structure and list them in the correct order </p>

</div>
</div>
<a id="a7bb6422a83deb2e9e7a51c9661509f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb6422a83deb2e9e7a51c9661509f79">&#9670;&nbsp;</a></span>findArrayDtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string omronUtilities::findArrayDtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;&#160;</td>
          <td class="paramname"><em>expandedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>arrayDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the datatype which an array type is defined with, this may be a structure name </p>

</div>
</div>
<a id="a1cac6bd5343b42da5f14fd3ff3ffb871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cac6bd5343b42da5f14fd3ff3ffb871">&#9670;&nbsp;</a></span>findOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omronUtilities::findOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;&#160;</td>
          <td class="paramname"><em>expandedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>structName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>structMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the main function responsible for calculating offsets. It looks a the expanded map and calculates the offset to each datatype by taking into account the size of the datatype and many alignment rules. It must take into account alignment rules from embedded arrays and structs as well as regular datatypes. It must keep track of both the current datatype and the next datatype to work out the alignment rules. </p>

</div>
</div>
<a id="a9051c9882f037fef52cfc9129a0e6394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9051c9882f037fef52cfc9129a0e6394">&#9670;&nbsp;</a></span>findRequestedOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omronUtilities::findRequestedOffset </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>structMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes the elements of a user defined structure requested by the user in the drvInfo string and finds their offsets from the previously created structMap_. The main purpose of this algorithm is to skip over embedded structs/arrays as we count through the map. For example, if I had a structure A with 2 elements, but the first was a 100byte structure, referencing A[2] would need to skip over this 100 byte structure. </p>

</div>
</div>
<a id="a7cae6bedc11d6478b0c2c52cc74cb7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cae6bedc11d6478b0c2c52cc74cb7c1">&#9670;&nbsp;</a></span>getBiggestDtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omronUtilities::getBiggestDtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;&#160;</td>
          <td class="paramname"><em>expandedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>structName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the largest standard datatype within a structure, this includes embedded structures and arrays and is used for calculating alignment </p>

</div>
</div>
<a id="af5f8a76977a452bb59294184bdaf5fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f8a76977a452bb59294184bdaf5fc1">&#9670;&nbsp;</a></span>getEmbeddedAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int omronUtilities::getEmbeddedAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#af4746cf9e32a31c72b35d5a55bf39e98">structDtypeMap</a> const &amp;&#160;</td>
          <td class="paramname"><em>expandedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>structName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nextItem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the alignment rules of an embedded structure or array, if nextItem is a structure then lookup the largest item in the structure. If nextItem is an array, then follow the alignment rule of the item after nextItem, if this item is a struct, then look up the largest item in this struct </p>

</div>
</div>
<a id="a1ebf2f148c6e02fa7828b9080574cf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebf2f148c6e02fa7828b9080574cf41">&#9670;&nbsp;</a></span>processExtrasExceptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void omronUtilities::processExtrasExceptions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>thisWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#a3d7ad34f0755c9afca3208c22f7afbf0">drvInfoMap</a> &amp;&#160;</td>
          <td class="paramname"><em>keyWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>extrasString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="drv_omroneip_8h.html#a3d7ad34f0755c9afca3208c22f7afbf0">drvInfoMap</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultTagAttribs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Some attributes entered by the user into the extras part of drvInfo need special attention. This function takes care of this and updates extrasString and keyWords </p>

</div>
</div>
<a id="a85d7a3f4f65a8ddda1ec2386935289b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d7a3f4f65a8ddda1ec2386935289b5">&#9670;&nbsp;</a></span>seperateDrvInfoVals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string omronUtilities::seperateDrvInfoVals </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes the drvInfo string and attempts to split it up around the spaces, then returns the values as a list of strings returns "true" or "false" to identify if drvInfo appears to be valid (additional checks are made later) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa2372cde9e153f6737e1d1f65ce2baad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2372cde9e153f6737e1d1f65ce2baad">&#9670;&nbsp;</a></span>driverName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* omronUtilities::driverName</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74b451095d9f8a31a33e42c3327f46e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b451095d9f8a31a33e42c3327f46e5">&#9670;&nbsp;</a></span>pasynUserSelf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asynUser* omronUtilities::pasynUserSelf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4704ea03c03ae7c9b4e7017e157ab212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4704ea03c03ae7c9b4e7017e157ab212">&#9670;&nbsp;</a></span>pDriver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrv_omron_e_i_p.html">drvOmronEIP</a>* omronUtilities::pDriver</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/omroneip/omroneip/omroneipApp/src/<a class="el" href="omron_utilities_8h_source.html">omronUtilities.h</a></li>
<li>/home/runner/work/omroneip/omroneip/omroneipApp/src/<a class="el" href="omron_utilities_8cpp.html">omronUtilities.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
